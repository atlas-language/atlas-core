use crate::lexer::Token;
use ordered_float::NotNan;

use crate::ast::{Pattern, LetBinding, Modifier, Literal,
    FnDeclaration, IfElse, ExprBlock, DeclBlock,
    Expr, Declaration, ReplInput, Record, Tuple, List};

grammar<'src>;

extern {
    enum Token<'src> {
        " " => Token::Whitespace(<&'src str>),
        "line_comment" => Token::LineComment(<&'src str>),
        "block_comment" => Token::BlockComment(<&'src str>),

        "true" => Token::True,
        "false" => Token::False,
        "integer" => Token::Integer(<u64>),
        "float" => Token::Float(<NotNan<f64>>),

        "enum" => Token::Enum,
        "fn" => Token::Fn,
        "let" => Token::Let,
        "if" => Token::If,
        "else" => Token::Else,

        "pub" => Token::Pub,
        "rec" => Token::Rec,

        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,

        "." => Token::Dot,
        "," => Token::Comma,
        ":" => Token::Colon,
        ";" => Token::Semicolon,

        "=" => Token::Equals,

        "-" => Token::Minus,

        "operator" => Token::Operator(<&'src str>),
        "identifier" => Token::Identifier(<&'src str>),

        "unknown" => Token::Unknown(<&'src str>)
    }
}

// Will match any token
AnyToken : Token<'src> = {
    " " => Token::Whitespace(<>),
    "line_comment" => Token::LineComment(<>),
    "block_comment" => Token::BlockComment(<>),

    "true" => Token::True,
    "false" => Token::False,
    "integer" => Token::Integer(<>),
    "float" => Token::Float(<>),

    "enum" => Token::Enum,
    "fn" => Token::Fn,
    "let" => Token::Let,
    "if" => Token::If,
    "else" => Token::Else,
    "pub" => Token::Pub,
    "rec" => Token::Rec,
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "(" => Token::LParen,
    ")" => Token::RParen,
    "." => Token::Dot,
    "," => Token::Comma,
    ":" => Token::Colon,
    ";" => Token::Semicolon,
    "=" => Token::Equals,
    "-" => Token::Minus,
    "operator" => Token::Operator(<>),
    "identifier" => Token::Identifier(<>),
    "unknown" => Token::Unknown(<>)
}

WS = {
    " ",
    "line_comment",
    "block_comment"
}

Literal : Literal<'src> = {
    "integer" => Literal::Integer(<> as i64),
    "float" => Literal::Float(<>),
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
    "(" ")" => Literal::Unit
}

Pattern : Pattern<'src> = {
    "identifier" => Pattern::Identifier(<>)
}

LetBinding : LetBinding<'src> = {
    "let" WS+ <pattern:Pattern> WS* "=" WS* <value:Expr> => LetBinding { pattern, value }
}

FnDeclaration : FnDeclaration<'src> = {
    "fn" WS <name:"identifier"> "(" <mut args:(<Pattern> ",")*> <last: Pattern> ")" WS <body: FunBody> => {
        args.push(last);
        FnDeclaration { name, args, body }
    }
}

Declaration: Declaration<'src> = {
    <LetBinding> ";" => Declaration::Let(<>),
    <FnDeclaration> => Declaration::Fn(<>)
}

IfElse : IfElse<'src> = {
    "if" " " <cond: Expr> " " "{" " "? <if_expr: Expr> " "? "}" " "? "else" " "? "{" " "? <else_expr: Expr> " "? "}" =>
        IfElse { cond, if_expr, else_expr }
}

Field : (&'src str, Expr<'src>) = {
    <i:"identifier"> WS* ":" <e:Expr> => (i,e)
}

Record : Record<'src> = {
    "{" <mut fields:(WS* <Field> ",")*> <f:Field?> "}" => 
        if let Some(f) = f { fields.push(f); }
        Record { fields }
}

Tuple : Tuple<'src> = {
    "(" "," ")" => Tuple { fields: vec![] },
    "(" <mut elems: (WS* <Expr>",")+> WS* <e:Expr?> ")" =>  {
        if let Some(e) = e { elems.push(e); }
        Tuple { fields: vec![] }
    }
}

List : List<'src> = {
    "[" <mut elems:(WS* <Expr> ",")*> WS* <e:Expr?>"]" => {
        if let Some(e) = e { elems.push(e); }
        List { elems }
    }
}

// Compact atomics do not include "open" expressions with spaces
// For instance, ls .la is *not* a compact expression, while
// ls.la, (ls . la) are compact expressions
CompactTerm : Expr<'src> = {
    Literal => Expr::Literal(<>),
    "(" WS* <e:Expr> ")" => e,
    "identifier" => Expr::Identifier(<>),
    ExprBlock => Expr::Block(Box::new(<>)),

    // Types
    <t:Tuple> => Expr::Tuple(t),
    <r:Record> => Expr::Record(r),
    <l:List> => Expr::List(l),

    // Compact call
    <func:CompactTerm> "(" <mut args:(WS* <Expr> ",")*> WS* <last: (<Expr>)?> ")" => {
        if let Some(l) = last { args.push(l); }
        Expr::Call(Box::new(func), args)
    },
    // Compact project operation
    <t:CompactTerm> "." <ident:"identifier"> =>
        Expr::Project(Box::new(t), ident),

    // Compact index operation
    <t:CompactTerm> "[" WS* <i:Term> "]" =>
        Expr::Index(Box::new(t), Box::new(i)),
}

// An Expr may have trailing whitespace
Term : Expr<'src> = {
    <l:Literal> WS* => Expr::Literal(l),
    "(" WS* <e:Expr> ")" WS* => e,
    <i:"identifier"> WS* => Expr::Identifier(i),
    <b:ExprBlock> WS* => Expr::Block(Box::new(b)),

    // Types
    <t:Tuple> WS* => Expr::Tuple(t),
    <r:Record> WS* => Expr::Record(r),
    <l:List> WS* => Expr::List(l),

    // Non-compact method call
    <func:Term> "(" <mut args:(WS* <Expr> ",")*> WS* <last: Expr?>")" WS* => {
        if let Some(l) = last { args.push(l); }
        Expr::Call(Box::new(func), args)
    },

    // Non-compact project operation
    <t:Term> "." WS* <ident:"identifier"> WS* =>
        Expr::Project(Box::new(t), ident),

    // Non-compact index operation
    <t:Term> "[" WS* <i:Term> "]" WS* =>
        Expr::Index(Box::new(t), Box::new(i)),
}

Operator : &'src str = {
    "-" => "-",
    "operator" => <>
}

CompactExpr : Expr<'src> = {
    CompactTerm => <>,
    <ops:Operator+> <e:CompactTerm> => {
        let mut x = e;
        for op in ops {
            x = Expr::Unary(op, Box::new(x))
        }
        x
    },
    // We allow multiple operators here, the others are interpreted
    // as unary operators applied to the RHS expression
    <lhs:CompactExpr> <op:Operator> <uops:Operator*> <mut rhs:CompactTerm> => {
        for op in &uops {
            rhs = Expr::Unary(op, Box::new(rhs))
        }
        match lhs {
            Expr::Infix(l, mut ops) => {
                ops.push((op, rhs));
                Expr::Infix(l, ops)
            },
            _ => Expr::Infix(Box::new(lhs), vec![(op, rhs)])
        }
    },
}

Expr: Expr<'src> = {
    Term => <>,
    <ops:(<Operator> WS*)+> <e:Term> => {
        let mut x = e;
        for op in ops {
            x = Expr::Unary(op, Box::new(x))
        }
        x
    },
    // We allow multiple operators here, the others are interpreted
    // as unary operators applied to the RHS expression
    <lhs:Expr> <op:Operator> WS* <uops:(<Operator> WS*)*> <mut rhs:Term> => {
        for op in &uops {
            rhs = Expr::Unary(op, Box::new(rhs))
        }
        match lhs {
            Expr::Infix(l, mut ops) => {
                ops.push((op, rhs));
                Expr::Infix(l, ops)
            },
            _ => Expr::Infix(Box::new(lhs), vec![(op, rhs)])
        }
    },
}

TLDeclaration: Declaration<'src> = {
    <LetBinding> ";"? => Declaration::Let(<>),
    <FnDeclaration> => Declaration::Fn(<>)
}

Modifier : Modifier = {
    "rec" => Modifier::Rec,
    "pub" => Modifier::Pub
}

// Exprblocks may only have rec
ExprBlock : ExprBlock<'src> = {
    <mods: (<Modifier> " ")*> "{" <decls: Declaration*> <value: Expr> "}" => 
        ExprBlock {  mods, decls, value: Some(value) }
}
FunBody: ExprBlock<'src> = {
    "{" <decls: Declaration*> <value: Expr?> "}" => 
        ExprBlock {  mods: vec![], decls, value }
}

// non-TL decl blocks may only have rec as a modifier, not pub
DeclBlock : DeclBlock<'src> = {
    <mods: (<Modifier> WS)+> "{" <decls: Declaration+> "}" =>
        DeclBlock { mods, decls }
}

// TL Decl block may have either "pub" or "rec" as a modifier
TLDeclBlock : DeclBlock<'src> = {
    <mods: (<Modifier> WS)+> "{" <decls: TLDeclaration+> "}" =>
        DeclBlock { mods, decls }
}

pub ReplInput : ReplInput<'src> = {
    WS? <TLDeclaration> => ReplInput::Declaration(<>),
    WS* <Expr> => ReplInput::Expr(<>),
    // No-arguments command
    ":" WS* <cmd: CompactExpr> => ReplInput::CommandInvoke(cmd, vec![]),
    // With-arguments command. 
    // Comment tokens and trailing
    // whitespace are removed
    ":" WS* <cmd: CompactExpr> WS <args:AnyToken+> => {
        let mut args : Vec<Token> = args.into_iter().filter(
            |v| match v {
                Token::BlockComment(_) => false,
                Token::LineComment(_) => false,
                _ => true
            }
        ).collect();
        if let Some(v) = args.pop() {
            if let Token::Whitespace(_) = v {
            } else {
                args.push(v)
            }
        }
        ReplInput::CommandInvoke(cmd, args)
    }
}

// pub ExprPack : Vec<Expr<'src>> = {
//     <WS?> <mut exprs: (<Expr> WS)*> <last: Expr?>
// }
